<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `predicates` macro in crate `swipl`."><meta name="keywords" content="rust, rustlang, rust-lang, predicates"><title>swipl::prelude::predicates - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../swipl/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location"><a href="../index.html">swipl</a>::<wbr><a href="index.html">prelude</a></p><div id="sidebar-vars" data-name="predicates" data-ty="macro" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Macro <a href="../index.html">swipl</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="macro" href="">predicates</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/swipl_macros/lib.rs.html#227" title="goto source code">[src]</a></span></h1><pre class="rust macro">predicates!() { /* proc-macro */ }</pre><div class="docblock"><p>Define foreign predicates written in rust for use in prolog.</p>
<p>The <code>predicates!</code> macro takes an arbitrary amount of predicate
definitions. These definitions may be semidet or
nondet. Optionally, a visibility specifier like <code>pub</code> may be used
to change the visibility of the generated functions. These
definitions look somewhat like ordinary rust functions. However,
their argument list is completely untyped, as each argument is
known to be a <code>&amp;Term</code>, except for the first argument which is a
context object. As there always needs to be a context to call a
predicate, this first argument is required, even if it is unused.</p>
<p>For each definition, a registration function will be
generated. This function will be named <code>register_&lt;name&gt;</code>, where
name is the name of the defined predicate, and this function will
take zero arguments. After calling this function, the predicate is
registered and may be used from prolog code.</p>
<p>Each definition may optionally be annotated with
<code>#[module(&quot;&lt;module&gt;&quot;)]</code> and/or <code>#[name(&quot;&lt;name&gt;&quot;)]</code> To change the
module this predicate will be registered in, or the name of the
predicate in prolog. By default, the predicate name will be the
definition name, and the module will be the context module at the
time of generation. For foreign libraries, this context module is
whatever module did the first import of this library. Otherwise
it's usually 'user'.</p>
<h1 id="semideterministic-predicates" class="section-header"><a href="#semideterministic-predicates">Semideterministic predicates</a></h1>
<p>The first kind of predicate that you can define is a semidet
predicate. Semidet, or semideterministic, means that this
predicate is only going to have one result, and it could either be
success or failure. Note that this also covers the deterministic
case - to implement a deterministic predicate, just ensure that
your predicate does not fail.</p>
<p>Semidet predicates return a <code>PrologResult&lt;()&gt;</code>, which also happens
to be the type returned by most of the functions in the <code>swipl</code>
library. This means you can easily handle failure and exception of
things you call using rust's <code>?</code> syntax, or make use of the various combinators that are defined on <code>context</code> objects and in the <code>result</code> module.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">predicates</span><span class="macro">!</span> {
    <span class="ident">semidet</span> <span class="kw">fn</span> <span class="ident">unify_with_foo</span>(<span class="ident">context</span>, <span class="ident">term</span>) {
        <span class="kw">let</span> <span class="ident">atom</span> <span class="op">=</span> <span class="ident">context</span>.<span class="ident">new_atom</span>(<span class="string">&quot;foo&quot;</span>);
        <span class="ident">term</span>.<span class="ident">unify</span>(<span class="kw-2">&amp;</span><span class="ident">atom</span>)
    }

    <span class="attribute">#[<span class="ident">module</span>(<span class="string">&quot;some_module&quot;</span>)]</span>
    <span class="attribute">#[<span class="ident">name</span>(<span class="string">&quot;some_alternate_name&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="ident">semidet</span> <span class="kw">fn</span> <span class="ident">term_is_42</span>(<span class="ident">_context</span>, <span class="ident">term</span>) {
        <span class="kw">let</span> <span class="ident">num</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="ident">term</span>.<span class="ident">get</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="ident">into_prolog_result</span>(<span class="ident">num</span> <span class="op">=</span><span class="op">=</span> <span class="number">42</span>)
    }

    <span class="ident">semidet</span> <span class="kw">fn</span> <span class="ident">just_fail</span>(<span class="ident">_context</span>) {
        <span class="prelude-val">Err</span>(<span class="ident">PrologError</span>::<span class="ident">Failure</span>)
    }

    <span class="kw">pub</span> <span class="ident">semidet</span> <span class="kw">fn</span> <span class="ident">throw_if_not_42</span>(<span class="ident">_context</span>, <span class="ident">term</span>) {
        <span class="kw">let</span> <span class="ident">num</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="ident">term</span>.<span class="ident">get</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;
        <span class="kw">if</span> <span class="ident">num</span> <span class="op">!</span><span class="op">=</span> <span class="number">42</span> {
            <span class="ident">context</span>.<span class="ident">raise_exception</span>(<span class="kw-2">&amp;</span><span class="macro">term</span><span class="macro">!</span>{<span class="ident">context</span>: <span class="ident">error</span>(<span class="ident">this_is_not_the_answer</span>, <span class="kw">_</span>)})
        } <span class="kw">else</span> {
            <span class="prelude-val">Ok</span>(())
        }
    }
}</pre></div>
<p>To register these defined predicates, their register function has to be called:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="ident">register_unify_with_foo</span>();
<span class="ident">register_term_is_42</span>();
<span class="ident">register_just_fail</span>();
<span class="ident">register_throw_if_not_42</span>();</pre></div>
<h1 id="nondeterministic-predicates" class="section-header"><a href="#nondeterministic-predicates">Nondeterministic predicates</a></h1>
<p>Nondet or nondeterministic predicates are a bit more complex to
implement. Instead of just one block which returns success or
failure, nondet predicates are implemented with two bodies, a
setup block and a call block.</p>
<p>In the setup block, you create a state object which will be
available in the call block. The call block is then called with
this state object. As long as the call block returns true, the
predicate call is considered to still have choice points and will
be called unless the caller does a cut, which will clean up the
state object automatically.</p>
<h2 id="the-state-type" class="section-header"><a href="#the-state-type">The state type</a></h2>
<p>Nondeterministic predicate definitions require you to specify a
type argument as part of the function signature. This specifies
the type of the state object, and is required to implement the
auto-traits <code>Send</code> and <code>Unpin</code>.</p>
<h2 id="setup" class="section-header"><a href="#setup">Setup</a></h2>
<p>The setup block is called at the start of a predicate
invocation. It is to return a <code>PrologResult&lt;Option&lt;StateObject&gt;&gt;</code>,
where <code>StateObject</code> is your state object type.</p>
<p>You can return from this block in three ways:</p>
<ul>
<li>Return an exception or failure. The predicate will error or fail accordingly and the call block will not be invoked.</li>
<li>Return <code>None</code>. The call block will also not be invoked, but the
predicate will return success. This is useful to handle predicate
inputs which allow your predicate to behave in a semidet manner.</li>
<li>Return <code>Some(object)</code>. This returns a state object for use in
the call block. After this, the call block will be invoked.</li>
</ul>
<h2 id="call" class="section-header"><a href="#call">Call</a></h2>
<p>The call block is called each time the next result is required from this predicate. This happens on the first call to this predicate (except if the setup returned early as described above), and subsequently upon backtracking. The call block is given a mutable borrow of the state object, and is therefore able to both inspect and modify it.</p>
<p>you can return from this block in three ways:</p>
<ul>
<li>Return an exception or failure. Thep redicate will error or fail accordingly, and the call block will not be invoked again.</li>
<li>Return false, signaling that this was the last succesful call to this predicate.</li>
<li>Return true, signaling that there's more results available upon backtracking.</li>
</ul>
<p>After exception, failure or returning false to signal the last succesful call, the state object will be cleaned up automatically.</p>
<h2 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h2>
<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">predicates</span><span class="macro">!</span>{
    <span class="ident">nondet</span> <span class="kw">fn</span> <span class="ident">unify_with_bar_baz</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">context</span>, <span class="ident">term</span>) {
        <span class="ident">setup</span> <span class="op">=</span><span class="op">&gt;</span> {
            <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>]))
        },
        <span class="ident">call</span>(<span class="ident">v</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="kw">let</span> <span class="ident">next</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">pop</span>().<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">atom</span> <span class="op">=</span> <span class="ident">context</span>.<span class="ident">new_atom</span>(<span class="ident">next</span>);
            <span class="ident">term</span>.<span class="ident">unify</span>(<span class="kw-2">&amp;</span><span class="ident">atom</span>)<span class="question-mark">?</span>;

            <span class="prelude-val">Ok</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">is_empty</span>())
        }
    }

    <span class="ident">nondet</span> <span class="kw">fn</span> <span class="ident">fail_early</span><span class="op">&lt;</span>()<span class="op">&gt;</span>(<span class="ident">_context</span>) {
        <span class="ident">setup</span> <span class="op">=</span><span class="op">&gt;</span> {
            <span class="prelude-val">Err</span>(<span class="ident">PrologError</span>::<span class="ident">Failure</span>)
        },
        <span class="ident">call</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// We never get here</span>
        }
    }

    <span class="ident">nondet</span> <span class="kw">fn</span> <span class="ident">succeed_early</span><span class="op">&lt;</span>()<span class="op">&gt;</span>(<span class="ident">_context</span>) {
        <span class="ident">setup</span> <span class="op">=</span><span class="op">&gt;</span> {
            <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>)
        },
        <span class="ident">call</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// We never get here</span>
        }
    }
}</pre></div>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="swipl"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>